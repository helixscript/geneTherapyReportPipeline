% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/connect_satalite_vertices.R
\name{connect_satalite_vertices}
\alias{connect_satalite_vertices}
\title{Connect integration sites which lie a specific gap distance away from a
cluster of integration sites.}
\usage{
connect_satalite_vertices(red.sites, graph, gap, bais)
}
\arguments{
\item{red.sites}{GRanges object which has been reduced to single nt positions
and contains the revmap from the original GRanges object. The object must
also contain a column for cluster membership (clus.id) and a column for
abundance (fragLengths).}

\item{graph}{a directed graph built from the red.sites object. Each node
corresponds to a row in the red.sites object.}

\item{gap}{integer nucleotide (nt) gap distance to consider joining to
clusters.}

\item{bias}{either "upsteam" or "downstream", designating which position to
choose if other decision metrics are tied.}
}
\description{
Given a list of unique integration site positions (reduced
GRanges object) and a directed graph of connected components, this function
identifies each node within gap range of clusters and creates an edge to
connect the cluster to the 'satalite' node. Edges are drawn from the last
node in the cluster to the 'satalite' node, but directionality is determined
first by abundance and secondly by an upstream bias.
}
\details{
\code{connect_satalite_vertices} returns a graph where nodes within 'gap'
distance from clusters are now connected to the edge of the clusters.
}
\examples{
gr <- gintools:::generate_test_granges(stdev = 3)
red.sites <- reduce(
  flank(gr, -1, start = TRUE),
  min.gapwidth = 0L,
  with.revmap = TRUE)
red.sites$siteID <- seq_along(red.sites)
revmap <- as.list(red.sites$revmap)
red.sites$fragLengths <- lengths(revmap)
red.hits <- GenomicRanges::as.data.frame(
  findOverlaps(red.sites, maxgap = 0L, drop.self = TRUE))
red.hits <- red.hits \%>\%
  mutate(q_pos = start(red.sites[queryHits])) \%>\%
  mutate(s_pos = start(red.sites[subjectHits])) \%>\%
  mutate(q_fragLengths = red.sites[queryHits]$fragLengths) \%>\%
  mutate(s_fragLengths = red.sites[subjectHits]$fragLengths) \%>\%
  mutate(strand = unique(strand(
    c(red.sites[queryHits], red.sites[subjectHits])))) \%>\%
  mutate(is.upstream = ifelse(
    strand == "+",
    q_pos < s_pos,
    q_pos > s_pos)) \%>\%
  mutate(keep = q_fragLengths > s_fragLengths) \%>\%
  mutate(keep = ifelse(
    q_fragLengths == s_fragLengths,
    is.upstream,
    keep)) \%>\%
  filter(keep)
g <- make_empty_graph(n = length(red.sites), directed = TRUE) \%>\%
  add_edges(unlist(mapply(
    c, red.hits$queryHits, red.hits$subjectHits, SIMPLIFY = FALSE)))
red.sites$clus.id <- clusters(g)$membership

connect_satalite_vertices(red.sites, g, gap = 2L, "upstream")

}
\author{
Christopher Nobles, Ph.D.
}
