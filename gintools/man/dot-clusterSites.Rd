% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/other_standardization_methods.R
\name{.clusterSites}
\alias{.clusterSites}
\title{Cluster/Correct values within a window based on their frequency given
discrete factors}
\usage{
.clusterSites(posID = NULL, value = NULL, grouping = NULL,
  psl.rd = NULL, weight = NULL, windowSize = 5L, byQuartile = FALSE,
  quartile = 0.7, parallel = TRUE, sonicAbund = FALSE)
}
\arguments{
\item{posID}{a vector of groupings for the value parameter (i.e. Chr,strand). Required if psl.rd parameter is not defined.}

\item{value}{a vector of integer with values that needs to corrected or
clustered (i.e. Positions). Required if psl.rd parameter is not defined.}

\item{grouping}{additional vector of grouping of length posID or psl.rd by
which to pool the rows (i.e. samplenames). Default is NULL.}

\item{psl.rd}{a GRanges object returned from \code{\link{getIntegrationSites}}.
Default is NULL.}

\item{weight}{a numeric vector of weights to use when calculating frequency
of value by posID and grouping if specified. Default is NULL.}

\item{windowSize}{size of window within which values should be corrected or
clustered. Default is 5.}

\item{byQuartile}{flag denoting whether quartile based technique should be
employed. See notes for details. Default is TRUE.}

\item{quartile}{if byQuartile=TRUE, then the quartile which serves as the
threshold. Default is 0.70.}

\item{parallel}{use parallel backend to perform calculation with
\code{\link{BiocParallel}}. Defaults to TRUE. If no parallel backend is
registered, then a serial version is ran using \code{\link{SerialParam}}.
Process is split by the grouping the column.}

\item{sonicAbund}{calculate breakpoint abundance using
\code{\link{getSonicAbund}}. Default is FALSE.}
}
\value{
a data frame with clusteredValues and frequency shown alongside with
the original input. If psl.rd parameter is defined then a GRanges object is
returned with three new columns appended at the end: clusteredPosition,
clonecount, and clusterTopHit (a representative for a given cluster chosen
by best scoring hit!).
}
\description{
Given a group of discrete factors (i.e. position ids) and integer values,
the function tries to correct/cluster the integer values based on their
frequency in a defined windowsize.
}
\note{
The algorithm for clustering when byQuartile=TRUE is as follows: for
all values in each grouping, get a distribution and test if their frequency
is >= quartile threshold. For values below the quartile threshold, test if
any values overlap with the ones that passed the threshold and is within the
defined windowSize. If there is a match, then merge with higher value, else
leave it as is. This is only useful if the distribution is wide and polynodal.
When byQuartile=FALSE, for each group the values within the defined window
are merged with the next highest frequently occuring value, if freuquencies
are tied then lowest value is used to represent the cluster. When psl.rd is
passed, then multihits are ignored and only unique sites are clustered. All
multihits will be tagged as a good 'clusterTopHit'.
}
\examples{
\donttest{
.clusterSites(posID=c('chr1-','chr1-','chr1-','chr2+','chr15-',
'chr16-','chr11-'), value=c(rep(1000,2),5832,1000,12324,65738,928042),
grouping=c('a','a','a','b','b','b','c'))
data(psl)
psl <- psl[sample(nrow(psl),100),]
psl.rd <- getIntegrationSites(pslToRangedObject(psl))
psl.rd$grouping <- sub("(.+)-.+","\\\\1",psl.rd$qName)
.clusterSites(grouping=psl.rd$grouping, psl.rd=psl.rd)
}
}
\seealso{
\code{\link{findIntegrations}}, \code{\link{getIntegrationSites}},
\code{\link{otuSites}}, \code{\link{isuSites}}, \code{\link{crossOverCheck}},
\code{\link{pslToRangedObject}}, \code{\link{getSonicAbund}}
}
\author{
Nirav Malani
}
